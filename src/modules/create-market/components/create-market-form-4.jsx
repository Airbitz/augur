import React from 'react';
import classNames from 'classnames';

import { get } from '../../../utils/get'

import FormButtons from '../../create-market/components/create-market-form-buttons';
import Input from '../../common/components/input';

module.exports = React.createClass({
	propTypes: {
		onValuesUpdated: React.PropTypes.func,
		errors: React.PropTypes.object,
		isValid: React.PropTypes.bool,

		tradingFeePercent: React.PropTypes.any,
		makerFeePercent: React.PropTypes.any,
		initialLiquidity: React.PropTypes.any,

		showAdvancedMarketParams: React.PropTypes.bool,

		initialFairPrice: React.PropTypes.any,
		sharesPerOrder: React.PropTypes.any,
		sizeOfBest: React.PropTypes.any,
		priceWidth: React.PropTypes.any,
		separation: React.PropTypes.any
	},

	render: function() {
		var p = this.props;

		const advancedParamsArrow = !!p.showAdvancedMarketParams ? '▲' : '▼'

		return (
			<div className="step-4">
				<div className="fee">
					<h4>Set the trading fee for your market</h4>
					<p>
						The Trading Fee is a percentage fee charged against the value of any trade made in the market.
						You'll receive 50% of all fees charged during the lifetime of your market - with the other
						50% being awarded to those reporting the outcome.
					</p>

					<Input
						type="text"
						value={ p.tradingFeePercent }
						isClearable={ false }
						onChange={ (value) => p.onValuesUpdated({ tradingFeePercent: value }) } />

					<span className="denomination">%</span>

					{ p.errors.tradingFeePercent &&
						<span className="error-message">{ p.errors.tradingFeePercent }</span>
					}
				</div>
				<div className="fee">
					<h4>Set the maker's share of the trading fee</h4>
					<p>
						The Maker Fee is the percentage split the 'Maker' of an order must pay of the trading fee with the remaining percentage being paid by the 'Taker'.
					</p>

					<Input
						type="text"
						value = { p.makerFeePercent }
						isClearable={ false }
						onChange={ (value) => p.onValuesUpdated({ makerFeePercent: value }) }
					/>
					<span className="denomination">%</span>

					{ p.errors.makerFeePercent &&
						<span className="error-message">{ p.errors.makerFeePercent }</span>
					}
				</div>
				<div className="liquidity">
					<h4>Set the amount of initial liquidity</h4>
					<p>
						Initial liquidity is the amount of ether you're putting into the market to get trading started.
						The Market Maker will use these funds to buy shares - which are then sold back to those
						wanting to trade your market when the market opens. Any initial liquidity remaining when
						the market is expired will be returned to you (along with any profit generated by the Market
						Maker from selling shares).
					</p>
					<Input
						type="text"
						value={ p.initialLiquidity }
						isClearable={ false }
						onChange={ (value) => p.onValuesUpdated({ initialLiquidity: value }) } />

					<span className="denomination">Eth</span>
					{ p.errors.initialLiquidity &&
						<span className="error-message">{ p.errors.initialLiquidity }</span>
					}
				</div>


				<div className="advanced-market-params" >
					<h6 className="horizontal-divider" onClick={() => {p.onValuesUpdated({ showAdvancedMarketParams: !p.showAdvancedMarketParams })}}><span>{ advancedParamsArrow }</span> Advanced <span>{ advancedParamsArrow }</span></h6>

					<div className={ classNames({ 'displayNone': !!!p.showAdvancedMarketParams }) }>

						<div>
							<h4>Initial Fair Price</h4>
							<p>
								This establishes the initial price for each respective outcome.
							</p>
							{ p.initialFairPrice.map((cV, i) => {
								return (
									<div key={`initialFairPrice${i}`} >
										<Input
											type="text"
											value={ p.initialFairPrice[i].value }
											isClearable={ false }
											onChange={
												(onChangeValue) => {
													let prices = p.initialFairPrice
													prices[i].value = onChangeValue

													p.onValuesUpdated({ initialFairPrice: prices })
												}
											} />
										<span className="denomination">{ cV.label }</span>
										{ !!get(p.errors, `initialFairPrice.${i}`) &&
											<span className="error-message">{ p.errors.initialFairPrice[`${i}`] }</span>
										}
									</div>
								)
							})}

						</div>

						<div>
							<h4>Shares Per Order</h4>
							<p>
								This is the number of shares in each order.
							</p>

							<Input
								type="text"
								value = { p.sharesPerOrder }
								isClearable={ false }
								onChange={ (value) => p.onValuesUpdated({ sharesPerOrder: value }) }
							/>

							{ p.errors.sharesPerOrder &&
								<span className="error-message">{ p.errors.sharesPerOrder }</span>
							}
						</div>

						<div>
							<h4>Size of best bid/ask</h4>
							<p>
								This defines the number of shares applied to the best bid and ask orders.
							</p>

							<Input
								type="text"
								value = { p.sizeOfBest }
								isClearable={ false }
								onChange={ (value) => p.onValuesUpdated({ sizeOfBest: value }) }
							/>

							{ p.errors.sizeOfBest &&
								<span className="error-message">{ p.errors.sizeOfBest }</span>
							}
						</div>

						<div>
							<h4>Price Width</h4>
							<p>
								This defines the spread between the initial best bid and ask orders.
							</p>

							<Input
								type="text"
								value = { p.priceWidth }
								isClearable={ false }
								onChange={ (value) => p.onValuesUpdated({ priceWidth: value }) }
							/>

							{ p.errors.priceWidth &&
								<span className="error-message">{ p.errors.priceWidth }</span>
							}
						</div>

						<div>
							<h4>Order Separation</h4>
							<p>
								This defines the price distance between all initial bids and asks.
							</p>

							<Input
								type="text"
								value = { p.separation }
								isClearable={ false }
								onChange={ (value) => p.onValuesUpdated({ separation: value }) }
							/>

							{ p.errors.separation &&
								<span className="error-message">{ p.errors.separation }</span>
							}
						</div>
					</div>
				</div>


				<FormButtons
					disabled={ !p.isValid }
					nextLabel="review"
					onNext={ () => p.onValuesUpdated({ step: p.step + 1 }) }
					onPrev={ () => p.onValuesUpdated({ step: p.step - 1 }) } />
			</div>
		);
	}
});